// BIMViewer.tsx - Main React component for 3D BIM visualization
import React, { useEffect, useRef, useState, useCallback } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { FirstPersonControls } from 'three/examples/jsm/controls/FirstPersonControls';
import Stats from 'three/examples/jsm/libs/stats.module';
import { GUI } from 'dat.gui';
import { 
  Components,
  FragmentsManager,
  IfcLoader,
  PropertiesManager,
  ClippingPlanes,
  Dimensions
} from '@thatopen/components';

interface BIMViewerProps {
  modelData?: {
    type: 'json_ifc' | 'binary_ifc';
    data: any;
    metadata: any;
  };
  height?: number;
  enableMeasurement?: boolean;
  enableWalkMode?: boolean;
  lodEnabled?: boolean;
  onElementSelect?: (elementId: string, properties: any) => void;
  onMeasurement?: (measurement: MeasurementData) => void;
}

interface MeasurementData {
  type: 'distance' | 'area' | 'volume';
  value: number;
  unit: string;
  points?: THREE.Vector3[];
}

interface ViewerState {
  loading: boolean;
  error: string | null;
  fps: number;
  memoryUsage: number;
  renderTime: number;
  mode: 'orbit' | 'walk';
}

export const BIMViewer: React.FC<BIMViewerProps> = ({
  modelData,
  height = 800,
  enableMeasurement = true,
  enableWalkMode = true,
  lodEnabled = true,
  onElementSelect,
  onMeasurement
}) => {
  const mountRef = useRef<HTMLDivElement>(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const controlsRef = useRef<OrbitControls | FirstPersonControls | null>(null);
  const statsRef = useRef<Stats | null>(null);
  const componentsRef = useRef<Components | null>(null);
  const animationIdRef = useRef<number | null>(null);
  
  const [state, setState] = useState<ViewerState>({
    loading: false,
    error: null,
    fps: 60,
    memoryUsage: 0,
    renderTime: 0,
    mode: 'orbit'
  });

  // Initialize Three.js scene
  const initScene = useCallback(() => {
    if (!mountRef.current) return;

    const width = mountRef.current.clientWidth;
    const height = mountRef.current.clientHeight;

    // Scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    scene.fog = new THREE.Fog(0xf0f0f0, 1000, 10000);
    sceneRef.current = scene;

    // Camera
    const camera = new THREE.PerspectiveCamera(
      45,
      width / height,
      0.1,
      10000
    );
    camera.position.set(100, 100, 100);
    camera.lookAt(0, 0, 0);
    cameraRef.current = camera;

    // Renderer with optimizations
    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true,
      powerPreference: 'high-performance',
      stencil: false,
      depth: true
    });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    // Enable GPU acceleration features
    renderer.physicallyCorrectLights = true;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1;
    
    mountRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
    directionalLight.position.set(100, 100, 50);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 500;
    scene.add(directionalLight);

    // Grid and axes
    const gridHelper = new THREE.GridHelper(1000, 100, 0x888888, 0xcccccc);
    scene.add(gridHelper);

    const axesHelper = new THREE.AxesHelper(50);
    scene.add(axesHelper);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 10;
    controls.maxDistance = 5000;
    controls.maxPolarAngle = Math.PI / 2;
    controlsRef.current = controls;

    // Stats
    if (process.env.NODE_ENV === 'development') {
      const stats = Stats();
      mountRef.current.appendChild(stats.dom);
      statsRef.current = stats;
    }

    // Initialize ThatOpen Components
    const components = new Components();
    components.scene = scene;
    components.camera = camera;
    components.renderer = renderer;
    componentsRef.current = components;

    // Add measurement tools
    if (enableMeasurement) {
      initMeasurementTools(components);
    }

    // Handle resize
    const handleResize = () => {
      if (!mountRef.current || !camera || !renderer) return;
      
      const width = mountRef.current.clientWidth;
      const height = mountRef.current.clientHeight;
      
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    };

    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
      if (mountRef.current && renderer.domElement) {
        mountRef.current.removeChild(renderer.domElement);
      }
      renderer.dispose();
    };
  }, [enableMeasurement]);

  // Initialize measurement tools
  const initMeasurementTools = (components: Components) => {
    const dimensions = new Dimensions(components);
    
    // Distance measurement
    const measureDistance = () => {
      dimensions.enabled = true;
      dimensions.createDimension();
    };

    // Area measurement
    const measureArea = () => {
      // Custom area measurement implementation
      console.log('Area measurement activated');
    };

    // Volume measurement
    const measureVolume = () => {
      // Custom volume measurement implementation
      console.log('Volume measurement activated');
    };

    // Add UI controls
    const gui = new GUI();
    const measureFolder = gui.addFolder('Measurement Tools');
    measureFolder.add({ distance: measureDistance }, 'distance').name('Measure Distance');
    measureFolder.add({ area: measureArea }, 'area').name('Measure Area');
    measureFolder.add({ volume: measureVolume }, 'volume').name('Measure Volume');
    measureFolder.open();
  };

  // Load IFC model with optimizations
  const loadModel = useCallback(async () => {
    if (!modelData || !componentsRef.current || !sceneRef.current) return;

    setState(prev => ({ ...prev, loading: true, error: null }));

    try {
      const components = componentsRef.current;
      const scene = sceneRef.current;

      // Initialize IFC loader
      const ifcLoader = new IfcLoader(components);
      
      // Configure for performance
      ifcLoader.settings = {
        COORDINATE_TO_ORIGIN: true,
        USE_FAST_BOOLS: true,
        OPTIMIZE_PROFILES: true,
        CIRCLE_SEGMENTS: 16,
        TAPE_SIZE: 10485760, // 10MB tape size for better memory usage
      };

      let model: any;

      if (modelData.type === 'json_ifc') {
        // Load from JSON schema (faster)
        model = await loadJsonIfc(modelData.data, components);
      } else {
        // Load binary IFC
        const blob = new Blob([modelData.data], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        model = await ifcLoader.load(url);
        URL.revokeObjectURL(url);
      }

      if (model) {
        scene.add(model);
        
        // Apply LOD if enabled
        if (lodEnabled) {
          applyLevelOfDetail(model);
        }

        // Setup spatial indexing for performance
        setupSpatialIndex(model);

        // Enable selection
        enableSelection(model, components);

        // Fit camera to model
        fitCameraToModel(model);
      }

      setState(prev => ({ ...prev, loading: false }));
    } catch (error) {
      console.error('Error loading model:', error);
      setState(prev => ({ 
        ...prev, 
        loading: false, 
        error: error.message || 'Failed to load model' 
      }));
    }
  }, [modelData, lodEnabled]);

  // Load JSON IFC schema (optimized format)
  const loadJsonIfc = async (jsonData: any, components: Components) => {
    // Create geometry from JSON data
    const geometry = new THREE.BufferGeometry();
    
    // Process vertices, normals, and indices from JSON
    if (jsonData.geometry) {
      const { vertices, normals, indices } = jsonData.geometry;
      
      geometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(vertices, 3)
      );
      
      if (normals) {
        geometry.setAttribute(
          'normal',
          new THREE.Float32BufferAttribute(normals, 3)
        );
      }
      
      if (indices) {
        geometry.setIndex(new THREE.Uint32BufferAttribute(indices, 1));
      }
    }

    // Create mesh with optimized material
    const material = new THREE.MeshLambertMaterial({
      color: 0xffffff,
      side: THREE.DoubleSide
    });

    const mesh = new THREE.Mesh(geometry, material);
    mesh.receiveShadow = true;
    mesh.castShadow = true;

    return mesh;
  };

  // Apply Level of Detail for performance
  const applyLevelOfDetail = (model: THREE.Object3D) => {
    const lod = new THREE.LOD();

    // High detail (close)
    lod.addLevel(model.clone(), 50);

    // Medium detail
    const mediumDetail = model.clone();
    simplifyGeometry(mediumDetail, 0.5);
    lod.addLevel(mediumDetail, 200);

    // Low detail (far)
    const lowDetail = model.clone();
    simplifyGeometry(lowDetail, 0.2);
    lod.addLevel(lowDetail, 500);

    model.parent?.add(lod);
    model.parent?.remove(model);
  };

  // Simplify geometry for LOD
  const simplifyGeometry = (object: THREE.Object3D, factor: number) => {
    object.traverse((child) => {
      if (child instanceof THREE.Mesh) {
        // Use THREE.SimplifyModifier or custom decimation
        // This is a placeholder for actual implementation
        child.geometry = child.geometry.clone();
      }
    });
  };

  // Setup spatial indexing for fast queries
  const setupSpatialIndex = (model: THREE.Object3D) => {
    // Implement octree or BVH for spatial queries
    // This enables fast raycasting and proximity queries
    console.log('Setting up spatial index...');
  };

  // Enable element selection
  const enableSelection = (model: THREE.Object3D, components: Components) => {
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    const handleClick = (event: MouseEvent) => {
      if (!mountRef.current || !cameraRef.current) return;

      const rect = mountRef.current.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, cameraRef.current);
      const intersects = raycaster.intersectObjects(model.children, true);

      if (intersects.length > 0) {
        const selected = intersects[0].object;
        
        // Highlight selection
        if (selected instanceof THREE.Mesh) {
          selected.material = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            opacity: 0.5,
            transparent: true
          });
        }

        // Get properties and notify
        const properties = getElementProperties(selected);
        onElementSelect?.(selected.uuid, properties);
      }
    };

    mountRef.current?.addEventListener('click', handleClick);
  };

  // Get element properties
  const getElementProperties = (element: THREE.Object3D) => {
    return {
      id: element.uuid,
      name: element.name,
      type: element.type,
      position: element.position,
      rotation: element.rotation,
      scale: element.scale,
      // IFC properties would be extracted here
    };
  };

  // Fit camera to model bounds
  const fitCameraToModel = (model: THREE.Object3D) => {
    if (!cameraRef.current || !controlsRef.current) return;

    const box = new THREE.Box3().setFromObject(model);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());

    const maxDim = Math.max(size.x, size.y, size.z);
    const fov = cameraRef.current.fov * (Math.PI / 180);
    const distance = maxDim / (2 * Math.tan(fov / 2));

    cameraRef.current.position.set(
      center.x + distance,
      center.y + distance,
      center.z + distance
    );

    cameraRef.current.lookAt(center);
    
    if (controlsRef.current instanceof OrbitControls) {
      controlsRef.current.target = center;
      controlsRef.current.update();
    }
  };

  // Toggle between orbit and walk mode
  const toggleNavigationMode = useCallback(() => {
    if (!cameraRef.current || !rendererRef.current) return;

    setState(prev => {
      const newMode = prev.mode === 'orbit' ? 'walk' : 'orbit';
      
      if (controlsRef.current) {
        controlsRef.current.dispose();
      }

      if (newMode === 'walk') {
        const walkControls = new FirstPersonControls(
          cameraRef.current!,
          rendererRef.current!.domElement
        );
        walkControls.movementSpeed = 100;
        walkControls.lookSpeed = 0.1;
        controlsRef.current = walkControls;
      } else {
        const orbitControls = new OrbitControls(
          cameraRef.current!,
          rendererRef.current!.domElement
        );
        orbitControls.enableDamping = true;
        controlsRef.current = orbitControls;
      }

      return { ...prev, mode: newMode };
    });
  }, []);

  // Animation loop with performance monitoring
  const animate = useCallback(() => {
    if (!sceneRef.current || !cameraRef.current || !rendererRef.current) return;

    const startTime = performance.now();

    // Update controls
    if (controlsRef.current) {
      if (controlsRef.current instanceof OrbitControls) {
        controlsRef.current.update();
      } else if (controlsRef.current instanceof FirstPersonControls) {
        controlsRef.current.update(0.016); // 60fps delta
      }
    }

    // Render scene
    rendererRef.current.render(sceneRef.current, cameraRef.current);

    // Update stats
    if (statsRef.current) {
      statsRef.current.update();
    }

    // Calculate performance metrics
    const renderTime = performance.now() - startTime;
    const memoryUsage = (performance as any).memory?.usedJSHeapSize || 0;

    // Update state periodically (every 60 frames)
    if (animationIdRef.current && animationIdRef.current % 60 === 0) {
      setState(prev => ({
        ...prev,
        fps: Math.round(1000 / renderTime),
        memoryUsage: memoryUsage / 1024 / 1024, // MB
        renderTime: renderTime
      }));
    }

    animationIdRef.current = requestAnimationFrame(animate);
  }, []);

  // Initialize scene on mount
  useEffect(() => {
    const cleanup = initScene();
    animate();

    return () => {
      if (animationIdRef.current) {
        cancelAnimationFrame(animationIdRef.current);
      }
      cleanup?.();
    };
  }, [initScene, animate]);

  // Load model when data changes
  useEffect(() => {
    if (modelData) {
      loadModel();
    }
  }, [modelData, loadModel]);

  return (
    <div className="bim-viewer-container" style={{ position: 'relative', height }}>
      {/* 3D Viewport */}
      <div 
        ref={mountRef} 
        style={{ 
          width: '100%', 
          height: '100%',
          position: 'relative',
          overflow: 'hidden'
        }} 
      />

      {/* Loading overlay */}
      {state.loading && (
        <div className="loading-overlay" style={{
          position: 'absolute',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          backgroundColor: 'rgba(255, 255, 255, 0.9)',
          zIndex: 1000
        }}>
          <div className="spinner">Loading model...</div>
        </div>
      )}

      {/* Error display */}
      {state.error && (
        <div className="error-message" style={{
          position: 'absolute',
          top: 20,
          left: '50%',
          transform: 'translateX(-50%)',
          backgroundColor: '#ff4444',
          color: 'white',
          padding: '10px 20px',
          borderRadius: 4,
          zIndex: 1001
        }}>
          Error: {state.error}
        </div>
      )}

      {/* Navigation controls */}
      <div className="navigation-controls" style={{
        position: 'absolute',
        bottom: 20,
        left: 20,
        display: 'flex',
        gap: 10,
        zIndex: 100
      }}>
        <button 
          onClick={toggleNavigationMode}
          style={{
            padding: '10px 20px',
            backgroundColor: '#007bff',
            color: 'white',
            border: 'none',
            borderRadius: 4,
            cursor: 'pointer'
          }}
        >
          {state.mode === 'orbit' ? 'ðŸš¶ Walk Mode' : 'ðŸ”„ Orbit Mode'}
        </button>

        {enableWalkMode && state.mode === 'walk' && (
          <div style={{ color: 'white', backgroundColor: 'rgba(0,0,0,0.7)', padding: 10, borderRadius: 4 }}>
            Use WASD to move, Mouse to look
          </div>
        )}
      </div>

      {/* Performance metrics */}
      {process.env.NODE_ENV === 'development' && (
        <div className="performance-metrics" style={{
          position: 'absolute',
          top: 20,
          right: 20,
          backgroundColor: 'rgba(0,0,0,0.7)',
          color: 'white',
          padding: 10,
          borderRadius: 4,
          fontFamily: 'monospace',
          fontSize: 12,
          zIndex: 100
        }}>
          <div>FPS: {state.fps}</div>
          <div>Memory: {state.memoryUsage.toFixed(1)} MB</div>
          <div>Render: {state.renderTime.toFixed(1)} ms</div>
        </div>
      )}
    </div>
  );
};

export default BIMViewer;